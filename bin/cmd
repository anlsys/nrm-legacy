#!/usr/bin/env python2

from __future__ import print_function
import argparse
import logging
import uuid
import signal
import zmq

logger = logging.getLogger('nrm-cmd')


class CommandLineInterface(object):

    """Implements a command line interface to the NRM."""

    def __init__(self):
        pass

    def do_signal(self, signum, stackframe):
        logger.info("received signal %d, exiting", signum)
        exit(1)

    def setup(self):
        # SUB port to the upstream API (connected to its PUB port)
        upstream_sub_port = 2345
        # PUB port to the upstream API (connected to its SUB port)
        upstream_pub_port = 3456

        self.context = zmq.Context()
        self.upstream_pub_socket = self.context.socket(zmq.PUB)
        self.upstream_sub_socket = self.context.socket(zmq.SUB)

        upstream_pub_param = "tcp://*:%d" % (upstream_pub_port)
        upstream_sub_param = "tcp://localhost:%d" % (upstream_sub_port)

        self.upstream_pub_socket.bind(upstream_pub_param)
        self.upstream_sub_socket.connect(upstream_sub_param)
        # we want to receive everything for now
        upstream_sub_filter = ""
        self.upstream_sub_socket.setsockopt(zmq.SUBSCRIBE, upstream_sub_filter)

        logger.info("upstream pub socket bound to: %s", upstream_pub_param)
        logger.info("upstream sub socket connected to: %s", upstream_sub_param)

        # take care of signals
        signal.signal(signal.SIGINT, self.do_signal)

        # create a uuid for this client instance
        self.uuid = str(uuid.uuid4())
        logger.info("client uuid: %r", self.uuid)

    def do_run(self, argv):
        """ Connect to the NRM and ask to spawn a container and run a command
        in it.

        The NRM should notify us on the pub socket of the container
        creation."""

        # build the command as a JSON dict containing enough info. We add to
        # the command a container uuid as a way to make sure that we can make
        # the command idempotent.
        containerid = str(uuid.uuid4())
        command = {'command': 'run',
                   'manifest': argv.manifest,
                   'file': argv.command,
                   'args': argv.args,
                   'uuid': containerid,
                   }

        while(True):
            self.upstream_pub_socket.send_json(command)
            msg = self.upstream_sub_socket.recv_json()
            logger.info("new message: %r", msg)
            # ignore other messages
            if isinstance(msg, dict) and msg.get('type') == 'container':
                if msg['uuid'] == containerid:
                    logger.info("container response: %r", msg)
                    break

    def do_list(self, argv):
        """Connect to the NRM and ask to list the containers present on the
        system.

        The NRM should respond to us on the pub socket with one message listing
        all containers."""

        command = {'command': 'list',
                   }

        while(True):
            self.upstream_pub_socket.send_json(command)
            msg = self.upstream_sub_socket.recv_json()
            logger.info("new message: %r", msg)
            # ignore other messages
            if isinstance(msg, dict) and msg.get('type') == 'container':
                if msg['event'] == 'list':
                    logger.info("list response: %r", msg)
                    break

    def do_kill(self, argv):
        """Connect to the NRM and ask to kill a container by uuid.

        The NRM should respond to us on the pub socket with a message
        containing the exit status of the top process of the container."""

        command = {'command': 'kill',
                   'uuid': argv.uuid
                   }

        while(True):
            self.upstream_pub_socket.send_json(command)
            msg = self.upstream_sub_socket.recv_json()
            logger.info("new message: %r", msg)
            # ignore other messages
            if isinstance(msg, dict) and msg.get('type') == 'container':
                if msg['event'] == 'exit' and msg['uuid'] == argv.uuid:
                    logger.info("container exit: %r", msg)
                    break

    def do_setpower(self, argv):
        """ Connect to the NRM and ask to change the power limit.

        The NRM should answer on the pub socket with an acknowledgment."""

        # build the command as a JSON dict giving enough info. This is an
        # idempotent command, so we will repeat the command if we don't get a
        # timely answer.
        # TODO: check that the level makes a little bit of sense in the first
        # place
        command = {'command': 'setpower',
                   'limit': argv.limit,
                   }

        while(True):
            self.upstream_pub_socket.send_json(command)
            msg = self.upstream_sub_socket.recv_json()
            logger.info("new message: %r", msg)
            # ignore other messages
            if isinstance(msg, dict) and msg.get('type') == 'power':
                if msg['limit'] == argv.limit:
                    logger.info("command received by the daemon")
                    break

    def main(self):
        parser = argparse.ArgumentParser()
        parser.add_argument("-v", "--verbose",
                            help="verbose logging information",
                            action='store_true')
        subparsers = parser.add_subparsers()

        # run container
        parser_run = subparsers.add_parser("run")
        parser_run.add_argument("manifest", help="manifest file to apply")
        parser_run.add_argument("command", help="command to execute")
        parser_run.add_argument("args", help="command arguments",
                                nargs=argparse.REMAINDER)
        parser_run.set_defaults(func=self.do_run)

        # kill container
        parser_kill = subparsers.add_parser("kill")
        parser_kill.add_argument("uuid", help="uuid of the container")
        parser_kill.set_defaults(func=self.do_kill)

        # list containers
        parser_list = subparsers.add_parser("list")
        parser_list.set_defaults(func=self.do_list)

        # setpowerlimit
        parser_setpower = subparsers.add_parser("setpower")
        parser_setpower.add_argument("-f", "--follow",
                                     help="listen for power changes",
                                     action='store_true')
        parser_setpower.add_argument("limit",
                                     help="set new power limit",
                                     type=float)
        parser_setpower.set_defaults(func=self.do_setpower)

        args = parser.parse_args()
        if args.verbose:
            logger.setLevel(logging.DEBUG)

        self.setup()
        args.func(args)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    cli = CommandLineInterface()
    cli.main()
